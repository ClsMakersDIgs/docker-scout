<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="en">
<head>
    <title>Legacy of Kain - Bat Form Flight</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: #2d1b2e;
            color: #8b6f8b;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #c9a96e;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 14px;
            line-height: 1.5;
        }
        
        #bat-hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            color: #8b6f8b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 12px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            color: #c9a96e;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        
        .gothic-border {
            border: 2px solid #8b6f8b;
            border-radius: 10px;
            padding: 10px;
            background: rgba(45, 27, 46, 0.8);
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="info" class="gothic-border">
        <strong>BAT FORM ACTIVATED</strong><br />
        WASD/Arrow Keys: Fly<br />
        Mouse: Look Around<br />
        Shift: Dive Faster<br />
        Space: Ascend<br />
        Click: Transform Back
    </div>
    
    <div id="crosshair">âœ¦</div>
    
    <div id="bat-hud" class="gothic-border">
        <div>Altitude: <span id="altitude">0</span>m</div>
        <div>Speed: <span id="speed">0</span> km/h</div>
        <div>Wind: <span id="wind">Calm</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        let container, camera, scene, renderer, controls;
        let mesh, texture, clock;
        let batWings = [];
        let isTransforming = false;
        let batSpeed = 0;
        let targetAltitude = 800;
        let windEffect = 0;
        
        const worldWidth = 256, worldDepth = 256;
        const keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false,
            sprint: false
        };
        
        init();
        animate();
        
        function init() {
            container = document.getElementById('container');
            clock = new THREE.Clock();
            
            // Camera setup for bat perspective
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 15000);
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d1b2e); // Dark gothic sky
            scene.fog = new THREE.FogExp2(0x4a3c4a, 0.0015); // Mystical fog
            
            // Generate Nosgoth-style terrain
            const data = generateNosothTerrain(worldWidth, worldDepth);
            
            // Position camera at bat flight height
            camera.position.set(100, 1200, -800);
            camera.lookAt(-100, 800, -800);
            
            // Create terrain geometry
            const geometry = new THREE.PlaneGeometry(12000, 12000, worldWidth - 1, worldDepth - 1);
            geometry.rotateX(-Math.PI / 2);
            
            const vertices = geometry.attributes.position.array;
            for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
                vertices[j + 1] = data[i] * 15; // More dramatic height
            }
            
            // Create gothic terrain texture
            texture = new THREE.CanvasTexture(generateGothicTexture(data, worldWidth, worldDepth));
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            
            mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture }));
            scene.add(mesh);
            
            // Add atmospheric lighting
            const moonlight = new THREE.DirectionalLight(0x9bb5ff, 0.3);
            moonlight.position.set(-1, 1, 1);
            scene.add(moonlight);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            scene.add(ambientLight);
            
            // Add floating particles for atmosphere
            createAtmosphericParticles();
            
            // Add bat wing shadows (visual effect)
            createBatWings();
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            setupControls();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick);
        }
        
        function generateNosothTerrain(width, height) {
            let seed = Math.PI / 3;
            window.Math.random = function() {
                const x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            };
            
            const size = width * height;
            const data = new Uint8Array(size);
            
            // Create more dramatic, castle-like terrain
            for (let i = 0; i < size; i++) {
                const x = i % width;
                const y = ~~(i / width);
                
                // Base elevation
                let elevation = Math.sin(x * 0.01) * 30 + Math.cos(y * 0.01) * 30;
                
                // Add castle-like structures
                if (Math.random() < 0.02) {
                    elevation += Math.random() * 80; // Tall spires
                }
                
                // Add valleys and ridges
                elevation += Math.sin(x * 0.05) * Math.cos(y * 0.05) * 20;
                
                data[i] = Math.max(0, Math.min(255, elevation + 50));
            }
            
            return data;
        }
        
        function generateGothicTexture(data, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            
            const context = canvas.getContext('2d');
            const imageData = context.createImageData(width, height);
            const pixels = imageData.data;
            
            for (let i = 0; i < data.length; i++) {
                const elevation = data[i];
                const pixelIndex = i * 4;
                
                // Gothic color scheme
                if (elevation < 60) {
                    // Dark valleys (purple/black)
                    pixels[pixelIndex] = 45;     // R
                    pixels[pixelIndex + 1] = 27; // G  
                    pixels[pixelIndex + 2] = 46; // B
                } else if (elevation < 120) {
                    // Mid elevation (dark brown/grey)
                    pixels[pixelIndex] = 60 + elevation * 0.3;
                    pixels[pixelIndex + 1] = 45 + elevation * 0.2;
                    pixels[pixelIndex + 2] = 50 + elevation * 0.25;
                } else {
                    // High peaks (lighter stone)
                    pixels[pixelIndex] = 100 + elevation * 0.4;
                    pixels[pixelIndex + 1] = 80 + elevation * 0.3;
                    pixels[pixelIndex + 2] = 85 + elevation * 0.35;
                }
                
                pixels[pixelIndex + 3] = 255; // Alpha
            }
            
            context.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        function createAtmosphericParticles() {
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = 500;
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 20000;     // x
                positions[i + 1] = Math.random() * 3000 + 500;    // y
                positions[i + 2] = (Math.random() - 0.5) * 20000; // z
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x9bb5ff,
                size: 3,
                transparent: true,
                opacity: 0.3
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }
        
        function createBatWings() {
            // Create subtle wing shadow effects on screen edges
            const wingGeometry = new THREE.PlaneGeometry(200, 100);
            const wingMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.1
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            
            leftWing.position.set(-300, 0, -100);
            rightWing.position.set(300, 0, -100);
            rightWing.scale.x = -1;
            
            camera.add(leftWing);
            camera.add(rightWing);
            
            batWings = [leftWing, rightWing];
        }
        
        function setupControls() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            
            // Lock pointer for better flight control
            container.addEventListener('click', () => {
                container.requestPointerLock();
            });
        }
        
        function onKeyDown(event) {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.forward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.backward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = true;
                    break;
                case 'Space':
                    keys.up = true;
                    event.preventDefault();
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    keys.down = true;
                    keys.sprint = true;
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch(event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    keys.forward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    keys.backward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'Space':
                    keys.up = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    keys.down = false;
                    keys.sprint = false;
                    break;
            }
        }
        
        function onMouseMove(event) {
            if (document.pointerLockElement === container) {
                const sensitivity = 0.002;
                camera.rotation.y -= event.movementX * sensitivity;
                camera.rotation.x -= event.movementY * sensitivity;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        }
        
        function onMouseClick() {
            // Transformation effect could be added here
            if (!isTransforming) {
                // Add transformation animation
                document.getElementById('info').innerHTML = '<strong>TRANSFORMING...</strong><br />Returning to vampire form...';
            }
        }
        
        function updateBatFlight() {
            const delta = clock.getDelta();
            const moveSpeed = keys.sprint ? 400 : 200;
            
            // Calculate movement direction
            const direction = new THREE.Vector3();
            
            if (keys.forward) direction.z -= 1;
            if (keys.backward) direction.z += 1;
            if (keys.left) direction.x -= 1;
            if (keys.right) direction.x += 1;
            if (keys.up) direction.y += 1;
            if (keys.down) direction.y -= 1;
            
            direction.normalize();
            direction.multiplyScalar(moveSpeed * delta);
            
            // Apply camera rotation to movement
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            const right = new THREE.Vector3();
            right.crossVectors(camera.up, cameraDirection).normalize();
            
            const movement = new THREE.Vector3();
            movement.addScaledVector(cameraDirection, -direction.z);
            movement.addScaledVector(right, direction.x);
            movement.addScaledVector(camera.up, direction.y);
            
            camera.position.add(movement);
            
            // Update bat speed for HUD
            batSpeed = direction.length() * moveSpeed * 3.6; // Convert to km/h approximation
            
            // Animate bat wings
            animateBatWings(delta);
            
            // Update HUD
            updateHUD();
        }
        
        function animateBatWings(delta) {
            const flapSpeed = 8;
            const flapAmount = 0.3;
            const time = Date.now() * 0.001;
            
            batWings.forEach((wing, index) => {
                const offset = index * Math.PI;
                wing.rotation.z = Math.sin(time * flapSpeed + offset) * flapAmount;
                wing.position.y = Math.sin(time * flapSpeed * 0.5 + offset) * 20;
            });
        }
        
        function updateHUD() {
            document.getElementById('altitude').textContent = Math.round(camera.position.y);
            document.getElementById('speed').textContent = Math.round(batSpeed);
            
            const windStrength = Math.sin(Date.now() * 0.001) * 0.5 + 0.5;
            if (windStrength < 0.3) {
                document.getElementById('wind').textContent = 'Calm';
            } else if (windStrength < 0.7) {
                document.getElementById('wind').textContent = 'Moderate';
            } else {
                document.getElementById('wind').textContent = 'Strong';
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updateBatFlight();
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>